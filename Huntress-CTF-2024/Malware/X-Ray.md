# X-Ray

![image](https://github.com/user-attachments/assets/a9bcf02f-d80d-4fe7-a099-439b6d81c6dd)

Download: [x-ray.7z](https://raw.githubusercontent.com/LazyTitan33/CTF-Writeups/refs/heads/main/Huntress-CTF-2024/challenge-files/x-ray.7z)

## My Solution

This archive just gives us a file called x-ray that cannot be identified. It just looks like data to the file command.  

![image](https://github.com/user-attachments/assets/9f217a0b-8025-412e-99d3-9a9119643f40)

However, we have a good starting point based on the challenge description. They state that the antivirus quarantined this file so logically, it must be an encrypted WIndows Defender file. To decrypt it, we can use [this](https://github.com/zam89/Windows-Defender-Quarantine-File-Decryptor) tool:  

We run it on our file and create a decrypted version:  

![image](https://github.com/user-attachments/assets/65ff5aa9-9b5b-48f2-af1b-03cad6e926f4)

This version can be identified to be a .Net binary:  

![image](https://github.com/user-attachments/assets/8fc6a0fd-1f70-4e2a-8634-f11e259ff2de)

Looking through the source code and asking chatGPT some questions we can pinpoint the interesting fuction for generating an OTP:  

![image](https://github.com/user-attachments/assets/d788e1b9-90bf-4352-bd73-cd7cf4ffb213)

To solve this and get the flag or decrypt the OTP (one-time pad) in the code, hereâ€™s a breakdown of the process:  
### Key Steps in the Decompiled Code:
1. **OTP (One-Time Pad) Decryption**:
    - The function `otp(byte[] data, byte[] key)` performs an XOR operation between the data and key byte arrays, which is the core of the OTP decryption.
    - The method `load(string hex)` converts a hex-encoded string into its byte array representation.
    - In the `Main` method, two hex-encoded strings are loaded using `load` and are XORed using the `otp` function.
    - The result is then converted back to a string using `Encoding.UTF8.GetString()`.

2. **Hexadecimal Data**:
    - The data and key for the OTP decryption are provided as hex-encoded strings.

### Steps to Decode the OTP:
1. **Convert Hex Strings to Byte Arrays**  
    - Convert both hex strings into byte arrays.

2. **Perform XOR (OTP Decryption)**  
    - XOR the two byte arrays element by element using the `otp` function.

3. **Convert the Result Back to String**  
    - Convert the resulting byte array into a UTF-8 string.


We have this python script doing the above and we get our flag:  

```python
def load(hex_str):
    # Convert the hex string into bytes
    return bytes.fromhex(hex_str)

def otp(data, key):
    # Perform XOR between data and key
    return bytes([d ^ key[i % len(key)] for i, d in enumerate(data)])

# Hex-encoded strings from the C# code
data_hex = "15b279d8c0fdbd7d4a8eea255876a0fd189f4fafd4f4124dafae47cb20a447308e3f77995d3c"
key_hex = "73de18bfbb99db4f7cbed3156d40959e7aac7d96b29071759c9b70fb18947000be5d41ab6c41"

# Load the hex strings into byte arrays
data_bytes = load(data_hex)
key_bytes = load(key_hex)

# Decrypt using the OTP method
decrypted_bytes = otp(data_bytes, key_bytes)

# Convert the decrypted bytes to a UTF-8 string
decrypted_string = decrypted_bytes.decode('utf-8')

# Print the decrypted string (hopefully the flag)
print(decrypted_string)
```

We can also do it with [cyberchef](https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')XOR(%7B'option':'Hex','string':'73de18bfbb99db4f7cbed3156d40959e7aac7d96b29071759c9b70fb18947000be5d41ab6c41'%7D,'Standard',false)&input=MTViMjc5ZDhjMGZkYmQ3ZDRhOGVlYTI1NTg3NmEwZmQxODlmNGZhZmQ0ZjQxMjRkYWZhZTQ3Y2IyMGE0NDczMDhlM2Y3Nzk5NWQzYw&oeol=FF).

`flag{df26090565cb329fdc8357080700b621}`
